// sha256.c is the same as sha256_generic-v07.cpp except that...
// 1. Renamed from cpp to c for consistency with mine.c which requires...
// typedef int bool;
// #define false 0
// #define true 1
// 3. Changed two declarations of "for (int i; ..." to declare int outside
// the for(), and one "for (int j; ..."
// 3. Removed main()
// 4. Renamed scan() as sha256_scan()
// 5. Moved malloc for work_restart from main to sha256_scan()
// 6. Tweaked printf of hash and removed gn and scanhash_c
// 7. Created sha256.h which contains declaration of ...
// int sha256_scan(char *golden_nonce_str, char *midstate_str, char *data_str);
// 

/* MJ See README_MJ_CheckHash-v01.txt for details, also checkhash-v01.py for working hash checker
 * Now requires command line parameters: golden_nonce midstate data
 *
 *
 * Cryptographic API.
 *
 * SHA-256, as specified in
 * http://csrc.nist.gov/groups/STM/cavp/documents/shs/sha256-384-512.pdf
 *
 * SHA-256 code by Jean-Luc Cooke <jlcooke@certainkey.com>.
 *
 * Copyright (c) Jean-Luc Cooke <jlcooke@certainkey.com>
 * Copyright (c) Andrew McDonald <andrew@mcdonald.org.uk>
 * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
 * SHA224 Support Copyright 2007 Intel Corporation <jonathan.lynch@intel.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * v06 - fix bug where error in work_decode resulted in exit status 0
 * v07 - fix bug where nonce 0xffffffff loops forever
 */

// #include "cpuminer-config.h"	.. MJ It's missing, probably generated by ./configure

#define _CRT_SECURE_NO_WARNINGS	// MJ Annoying!!

#include <stdio.h>		// MJ Adds
#include <stdarg.h>		// MJ Adds
// #include <alloca.h>		// MJ Adds, but its not there, so
#include <malloc.h>		// MJ Adds

#include "stdint.h"		// Not found, so copied from C:\MinGW\include and change from <> to ""

//#include <stdbool.h>	// HMMM, can't find this, but does not matter in cpp
						// However it DOES in .c so add...
typedef int bool;
#define false 0
#define true 1

#include <stdlib.h>
#include <string.h>
// #include "miner.h"	// Its a mess so I'll just put stuff here as I need it

// MJ Don't want to #include "windows.h" so ...
unsigned int ntohl(unsigned int in)	// Only used in debug to check the reversed golden_nonce
{
	return ((in & 0xff) << 24) | ((in & 0xff00) << 8) | ((in & 0xff0000) >> 8) | ((in & 0xff000000) >> 24);
}

// MJ from miner.h ...
#define unlikely(expr) (expr)

extern bool fulltest(const unsigned char *hash, const unsigned char *target);
struct work_restart {
	volatile unsigned long	restart;
	char			padding[128 - sizeof(unsigned long)];
};
extern struct work_restart *work_restart;
static inline void swap256(void *dest_p, const void *src_p)
{
	uint32_t *dest = (uint32_t *)dest_p;
	const uint32_t *src = (uint32_t *)src_p;

	dest[0] = src[7];
	dest[1] = src[6];
	dest[2] = src[5];
	dest[3] = src[4];
	dest[4] = src[3];
	dest[5] = src[2];
	dest[6] = src[1];
	dest[7] = src[0];
}
#define	bswap_16(value)  \
 	((((value) & 0xff) << 8) | ((value) >> 8))

#define	bswap_32(value)	\
 	(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
 	(uint32_t)bswap_16((uint16_t)((value) >> 16)))
 
#define	bswap_64(value)	\
 	(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
 	    << 32) | \
 	(uint64_t)bswap_32((uint32_t)((value) >> 32)))
static inline uint32_t swab32(uint32_t v)
{
#ifdef WANT_BUILTIN_BSWAP
	return __builtin_bswap32(v);
#else
	return bswap_32(v);
#endif
}
extern char *bin2hex(const unsigned char *p, size_t len);
extern bool hex2bin(unsigned char *p, const char *hexstr, size_t len);

bool opt_debug;	// MJ remove extern
enum {
	LOG_ERR,
	LOG_WARNING,
	LOG_INFO,
	LOG_DEBUG,
};
extern void applog(int prio, const char *fmt, ...);

// MJ END from miner.h

// MJ from util.c ...

char *bin2hex(const unsigned char *p, size_t len)
{
	int i;
	char *s = (char*)malloc((len * 2) + 1);
	if (!s)
		return NULL;

	for (i = 0; i < len; i++)
		sprintf(s + (i * 2), "%02x", (unsigned int) p[i]);

	return s;
}

bool hex2bin(unsigned char *p, const char *hexstr, size_t len)
{
	while (*hexstr && len) {
		char hex_byte[3];
		unsigned int v;

		if (!hexstr[1]) {
			applog(LOG_ERR, "hex2bin str truncated");
			return false;
		}

		hex_byte[0] = hexstr[0];
		hex_byte[1] = hexstr[1];
		hex_byte[2] = 0;

		if (sscanf(hex_byte, "%x", &v) != 1) {
			applog(LOG_ERR, "hex2bin sscanf '%s' failed", hex_byte);
			return false;
		}

		*p = (unsigned char) v;

		p++;
		hexstr += 2;
		len--;
	}

	return (len == 0 && *hexstr == 0) ? true : false;
}

// MJ Too complex, use simpler version ...
void applog(int prio, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	char *f;
	int	len = strlen(fmt) + 2;
	f = (char*)alloca(len);
	sprintf(f, "%s\n", fmt);	// MJ omit date
	vfprintf(stderr, f, ap);	/* atomic write to stderr */
	va_end(ap);
}

#if 0	// MJ Too complex, use simpler version above
void applog(int prio, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);

#ifdef HAVE_SYSLOG_H
	if (use_syslog) {
		vsyslog(prio, fmt, ap);
	}
#else
	if (0) {}
#endif
	else {
		char *f;
		int len;
		struct timeval tv = { };
		struct tm tm, *tm_p;

		gettimeofday(&tv, NULL);

		pthread_mutex_lock(&time_lock);
		tm_p = localtime(&tv.tv_sec);
		memcpy(&tm, tm_p, sizeof(tm));
		pthread_mutex_unlock(&time_lock);

		len = 40 + strlen(fmt) + 2;
		f = alloca(len);
		sprintf(f, "[%d-%02d-%02d %02d:%02d:%02d] %s\n",
			tm.tm_year + 1900,
			tm.tm_mon + 1,
			tm.tm_mday,
			tm.tm_hour,
			tm.tm_min,
			tm.tm_sec,
			fmt);
		vfprintf(stderr, f, ap);	/* atomic write to stderr */
	}
	va_end(ap);
}
#endif

// MJ END from util.c

struct work {							// MJ from cpu_miner.c
	unsigned char	data[128];
	unsigned char	hash1[64];
	unsigned char	midstate[32];
	unsigned char	target[32];

	unsigned char	hash[32];
};

struct work_restart *work_restart = NULL;	// MJ from cpu_miner.c

typedef  unsigned int uint32_t;	// MJ
typedef  unsigned char uint8_t; // MJ

typedef uint32_t u32;
typedef uint8_t u8;

static inline u32 ror32(u32 word, unsigned int shift)
{
	return (word >> shift) | (word << (32 - shift));
}

static inline u32 Ch(u32 x, u32 y, u32 z)
{
	return z ^ (x & (y ^ z));
}

static inline u32 Maj(u32 x, u32 y, u32 z)
{
	return (x & y) | (z & (x | y));
}

#define e0(x)       (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22))
#define e1(x)       (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25))
#define s0(x)       (ror32(x, 7) ^ ror32(x,18) ^ (x >> 3))
#define s1(x)       (ror32(x,17) ^ ror32(x,19) ^ (x >> 10))

static inline void LOAD_OP(int I, u32 *W, const u8 *input)
{
	/* byteswap is commented out, because bitcoin input
	 * is already big-endian
	 */
	W[I] = /* ntohl */ ( ((u32*)(input))[I] );
}

static inline void BLEND_OP(int I, u32 *W)
{
	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
}

static void sha256_transform(u32 *state, const u8 *input)
{
	u32 a, b, c, d, e, f, g, h, t1, t2;
	u32 W[64];
	int i;

	/* load the input */
	for (i = 0; i < 16; i++)		// MJ input is cast to u32* so this processes 16 DWORDS = 64 bytes
		LOAD_OP(i, W, input);

	/* now blend */
	for (i = 16; i < 64; i++)
		BLEND_OP(i, W);

	/* load the state into our registers */
	a=state[0];  b=state[1];  c=state[2];  d=state[3];
	e=state[4];  f=state[5];  g=state[6];  h=state[7];

	/* now iterate */
	t1 = h + e1(e) + Ch(e,f,g) + 0x428a2f98 + W[ 0];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0x71374491 + W[ 1];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0xb5c0fbcf + W[ 2];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0xe9b5dba5 + W[ 3];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x3956c25b + W[ 4];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0x59f111f1 + W[ 5];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x923f82a4 + W[ 6];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0xab1c5ed5 + W[ 7];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0xd807aa98 + W[ 8];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0x12835b01 + W[ 9];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0x243185be + W[10];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0x550c7dc3 + W[11];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x72be5d74 + W[12];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0x80deb1fe + W[13];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x9bdc06a7 + W[14];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0xc19bf174 + W[15];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0xe49b69c1 + W[16];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0xefbe4786 + W[17];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0x0fc19dc6 + W[18];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0x240ca1cc + W[19];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x2de92c6f + W[20];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0x4a7484aa + W[21];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x5cb0a9dc + W[22];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0x76f988da + W[23];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0x983e5152 + W[24];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0xa831c66d + W[25];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0xb00327c8 + W[26];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0xbf597fc7 + W[27];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0xc6e00bf3 + W[28];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0xd5a79147 + W[29];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x06ca6351 + W[30];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0x14292967 + W[31];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0x27b70a85 + W[32];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0x2e1b2138 + W[33];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0x4d2c6dfc + W[34];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0x53380d13 + W[35];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x650a7354 + W[36];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0x766a0abb + W[37];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x81c2c92e + W[38];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0x92722c85 + W[39];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0xa2bfe8a1 + W[40];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0xa81a664b + W[41];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0xc24b8b70 + W[42];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0xc76c51a3 + W[43];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0xd192e819 + W[44];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0xd6990624 + W[45];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0xf40e3585 + W[46];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0x106aa070 + W[47];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0x19a4c116 + W[48];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0x1e376c08 + W[49];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0x2748774c + W[50];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0x34b0bcb5 + W[51];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x391c0cb3 + W[52];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0x4ed8aa4a + W[53];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0x5b9cca4f + W[54];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0x682e6ff3 + W[55];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	t1 = h + e1(e) + Ch(e,f,g) + 0x748f82ee + W[56];
	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
	t1 = g + e1(d) + Ch(d,e,f) + 0x78a5636f + W[57];
	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
	t1 = f + e1(c) + Ch(c,d,e) + 0x84c87814 + W[58];
	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
	t1 = e + e1(b) + Ch(b,c,d) + 0x8cc70208 + W[59];
	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
	t1 = d + e1(a) + Ch(a,b,c) + 0x90befffa + W[60];
	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
	t1 = c + e1(h) + Ch(h,a,b) + 0xa4506ceb + W[61];
	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
	t1 = b + e1(g) + Ch(g,h,a) + 0xbef9a3f7 + W[62];
	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
	t1 = a + e1(f) + Ch(f,g,h) + 0xc67178f2 + W[63];
	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;

	state[0] += a; state[1] += b; state[2] += c; state[3] += d;
	state[4] += e; state[5] += f; state[6] += g; state[7] += h;

#if 0
	/* clear any sensitive info... */
	a = b = c = d = e = f = g = h = t1 = t2 = 0;
	memset(W, 0, 64 * sizeof(u32));
#endif
}

static void runhash(void *state, const void *input, const void *init)
{
	memcpy(state, init, 32);
	// sha256_transform(state, input);
	sha256_transform((u32*)state, (const u8*)input); // MJ
}

const uint32_t sha256_init_state[8] = {
	0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
};

/* suspiciously similar to ScanHash* from bitcoin */
bool scanhash_c(int thr_id, const unsigned char *midstate, unsigned char *data,
	        unsigned char *hash, const unsigned char *target,
	        uint32_t max_nonce, unsigned long *hashes_done)
{
	uint32_t *hash32 = (uint32_t *) hash;
	uint32_t *nonce = (uint32_t *)(data + 12);

	// MJ We are passed only the second half of the 128 byte data, so processing 64 bytes (512 bits)
	//    The nonce is inserted into bit positions 96..127 (byte offset 12..15)

	// MJ Modified to scan max_nonce only
	// uint32_t n = 0;
	uint32_t n = max_nonce;
	
	unsigned long stat_ctr = 0;

	work_restart[thr_id].restart = 0;

	// MJ EEEK, this loops forever if passed 0xFFFFFFFF for nonce, so make it happen ONCE only
	// Removed while, now its a bare block
	{
		// This DOES make a difference to the final hash, but not to intermediate the intermediate hash1 result
		// unsigned char hash1[32];	// BUG ??
		unsigned char hash1[64] = { 0 };	// MJ

		*nonce = n;		// MJ This sets ((char*)data)[12] = nonce ie bits 96..127
		n++;			// MJ Swapped this to below above line so we scan max_nonce


		// runhash 1st argument is output - runhash copies 3rd arg to 1st arg then sha256 with 2nd arg
		// NB static void runhash(void *state, const void *input, const void *init)
		// output state is 32 bytes, input is 64 bytes, init is 32 ...
		// ... then why is it hash1[32] above? should be 64 to match data ... BUG??
		// NB midstate is the result of the first sha256 loop operation on the message (done by JSON server),
		// we are simply completing the hash with the second set of data here (the original message is 80
		// bytes, hence needs two operations as its bigger than the 448bit threshold for a single round).
		runhash(hash1, data, midstate);

		// For gn = 75967de3, the following is the CORRECT hash1 (checked with midhash.py)
		// hash  1  = <a3569b7c22dc9778ca48830cb8349465caef1c9c4a2e564f0e7c21d4b8252710>
#if 0 // DEBUG
	printf("hash (1) = <");
	for (int i=0; i<sizeof(hash1); i++)
		printf("%02x",hash1[i]);
	printf(">\n");
#endif

		// CONCLUDE ... its correct up to this point, but we are let down by the following ...
		// runhash(hash, hash1, sha256_init_state);

		// THIS WORKS ... compute the hash using the standard algorithm (see wikipedia SHA-2 article)
		// NB We assume hash1 has been initialized to 0, apart from the first 32 bytes
		hash1[35] = 0x80;	// Append a 1 (big endian)
		hash1[61] = 1;		// Append length = 256 (big endian)

	int i;
#if 0 // DEBUG
	printf("hash (2) = <");
	for (i=0; i<sizeof(hash1); i++)
		printf("%02x",hash1[i]);
	printf(">\n");
#endif
		runhash(hash, hash1, sha256_init_state);

#if 1 // DEBUG
	// printf("hash OUT = <");
	printf("hash=");
	for (i=0; i<32; i++)
		printf("%02x",hash[i]);
	printf("\n");
#endif
		stat_ctr++;

		// MJ BUT fulltest() is hard coded to return true !!!
		// So we're just testing for (hash32[7] == 0) which is the top DWORD of the hash

		if (unlikely((hash32[7] == 0) && fulltest(hash, target))) {
			*hashes_done = stat_ctr;
			return true;
		}

		// MJ We are no longer looping, so just return false
		// if ((n >= max_nonce) || work_restart[thr_id].restart) {
		//	*hashes_done = stat_ctr;
		return false;
	}
}

bool fulltest(const unsigned char *hash, const unsigned char *target)
{
	unsigned char hash_swap[32], target_swap[32];
	uint32_t *hash32 = (uint32_t *) hash_swap;
	uint32_t *target32 = (uint32_t *) target_swap;
	int i;
	bool rc = true;
	char *hash_str, *target_str;

	swap256(hash_swap, hash);
	swap256(target_swap, target);

	for (i = 0; i < 32/4; i++) {
		uint32_t h32tmp = swab32(hash32[i]);
		uint32_t t32tmp = target32[i];

		target32[i] = swab32(target32[i]);	/* for printing */

		if (h32tmp > t32tmp) {
			rc = false;
			break;
		}
		if (h32tmp < t32tmp) {
			rc = true;
			break;
		}
	}

	if (opt_debug) {
		hash_str = bin2hex(hash_swap, 32);
		target_str = bin2hex(target_swap, 32);

		applog(LOG_DEBUG, " Proof: %s\nTarget: %s\nTrgVal? %s",
			hash_str,
			target_str,
			rc ? "YES (hash < target)" :
			     "no (false positive; hash > target)");

		free(hash_str);
		free(target_str);
	}

	// MJ YIKES ... so we ignore the result entirely !! REINSTATED IT.
	// return true;	/* FIXME: return rc; */
	if (!rc) printf("WARNING fulltest FAILED\n");
	return rc;
}

// MJ These from cpu-miner.c to load data

// MJ Original uses json and curl, so modify to omit these and load my data directly

typedef char json_t;		// MJ just make it a string. NB char, not char*

// MJ I actually pack the four null terminated strings (midstate, data, hash1, target) sequentially into a json_t
// A struct would be better, but for now we'll stick with a string

json_t* json_object_get(const json_t *obj, const char *key)
{
	// MJ Roll my own version
	if (!key)
		return NULL;
	int i;
	if (!strcmp(key,"midstate")) i = 0;
	else if (!strcmp(key,"data")) i = 1;
	else if (!strcmp(key,"hash1")) i = 2;
	else if (!strcmp(key,"target")) i = 3;
	else return NULL;

	// No error check, just assume four strings
	json_t *p = (json_t *)obj;
	while (i--)
	{
		while (*p)
			p++;
		p++;
	}
	return p;
}

char* json_string_value(const json_t *obj)
{
	// MJ Roll my own version
	return (char*)obj; // That's all that we need!
}

static bool jobj_binary(const json_t *obj, const char *key,
			void *buf, size_t buflen)
{
	const char *hexstr;
	json_t *tmp;
	tmp = json_object_get(obj, key);
	if (unlikely(!tmp)) {
		applog(LOG_ERR, "JSON key '%s' not found", key);
		return false;
	}
// printf("AT 1 tmp=<%s>\n", (char*)tmp);
	hexstr = json_string_value(tmp);
	if (unlikely(!hexstr)) {
		applog(LOG_ERR, "JSON key '%s' is not a string", key);
		return false;
	}
// printf("AT 2 strlen(hexstr)=%d bufflen=%d\n", strlen((char*)hexstr), buflen);
// printf("hexstr=<%s>\n", (char*)hexstr);
	if (!hex2bin((unsigned char*)buf, hexstr, buflen))
		return false;
// printf("AT 3\n");

	return true;
}

// static bool work_decode(const json_t *val, struct work *work)	// MJ Original uses json and curl
static bool work_decode(const json_t *val, struct work *work)
{
	if (unlikely(!jobj_binary(val, "midstate",
			 work->midstate, sizeof(work->midstate)))) {
		applog(LOG_ERR, "JSON inval midstate");
		goto err_out;
	}

	if (unlikely(!jobj_binary(val, "data", work->data, sizeof(work->data)))) {
		applog(LOG_ERR, "JSON inval data");
		goto err_out;
	}

	if (unlikely(!jobj_binary(val, "hash1", work->hash1, sizeof(work->hash1)))) {
		applog(LOG_ERR, "JSON inval hash1");
		goto err_out;
	}

	if (unlikely(!jobj_binary(val, "target", work->target, sizeof(work->target)))) {
		applog(LOG_ERR, "JSON inval target");
		goto err_out;
	}

	memset(work->hash, 0, sizeof(work->hash));

	return true;

err_out:
	return false;
}

void reversehex(char *s)	// NO LONGER USED
{
	// MJ Reverse a hex string - NB we reverse in blocks of 4 bytes
	// Lazy way ...
	int len = strlen(s);

	// Insist on multiples of 4 bytes (8 hex chars)
	if (len%8)
		return;		// String unchanged

	char *d = (char*)malloc(len+1);
	if (!d)
		return;
	memset(d, 0, len+1);

	int i,j;
	for (j=0; j<len; j+=8)
	{
		for (i=0; i<8; i+=2)
		{
			// NB hex pairs are kept together (reversing bytes, not the hex chars which represent nibbles)
			d[j+8-i-2] = s[j+i];
			d[j+8-i-1] = s[j+i+1];
		}
	}
	strcpy(s,d);	// Set result
	free(d);
}

int sha256_scan(char *golden_nonce_str, char *midstate_str, char *data_str)
{
	// Test data from log ...
	/*
	ORDER...
	midstate
	data
	hash
	target
JSON
5ae6ea1a1e620b29ed492953833168324b62f525a7e3269120c1547e98d12d88
00000001924f644fe5efd091e68e433396e39f509d9627d994834fa30000025b00000000af14ab5d1e849cb080aced38074f783fb62c21188bed86ab6252d9d5d8b3aa29508f1e5e1a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
JSON
86b0a0d2c3f791243fde46e89bad512b4be0f45fcc228b5f5e43e9694d779dd6
00000001924f644fe5efd091e68e433396e39f509d9627d994834fa30000025b00000000b2c4ce9fd6afdcf5f511368d22c8be843bf094bcc5e920608002ef6bf07fec77508f1e731a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
GOLDEN
	** Golden Nonce **
	[10/30/2012 00:25:34] eafb90b1 accepted
	*/
	
	// This was done in main(), but needs to be here sha256.c
	// MJ Allocate some memory for work_restart (we don't bother freeing it)
	/// ... it is now free'd on return
	if (!work_restart)
		work_restart = (struct work_restart*) malloc (sizeof(struct work_restart));
	if (!work_restart)
		return 1;

	// MJ We need to fill these in ...
	
	// MJ from struct work in cpu-miner.c
	/* 
	struct work {
		unsigned char	data[128];		// 128 bytes, but 1st 64 are ignored and the nonce gets poked in partway along it
		unsigned char	hash1[64];		// The JSON hash goes here (its ignored anyway)
		unsigned char	midstate[32];
		unsigned char	target[32];		// This is also ignored .. see full_check which always returns true
		unsigned char	hash[32];
	};
	*/

	// This is our test JSON data as logged by miner json_rpc.tcl ... the data and hash fields are BIGER
#if 0
	char midstate_str[] = "5ae6ea1a1e620b29ed492953833168324b62f525a7e3269120c1547e98d12d88";
	char data_str[] = "00000001924f644fe5efd091e68e433396e39f509d9627d994834fa30000025b00000000b2c4ce9fd6afdcf5f511368d22c8be843bf094bcc5e920608002ef6bf07fec77508f1e731a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 0
	char midstate_str[] = "86b0a0d2c3f791243fde46e89bad512b4be0f45fcc228b5f5e43e9694d779dd6";
	char data_str[] = "00000001924f644fe5efd091e68e433396e39f509d9627d994834fa30000025b00000000b2c4ce9fd6afdcf5f511368d22c8be843bf094bcc5e920608002ef6bf07fec77508f1e731a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

/*
JSON
a05f72040d21ae874e7abb671a16c520f65b27c0fe8fff32bfdc0ccf0119886f
00000001e7a4f93a0e9c09883e248e014670d9ac08cf89c156ef660e0000003a000000007aef3c141a26ecf22af62d6779290ea3fffaf9c19fb7daf652fee184d30d3131508fab7c1a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
JSON
96a1e5cb2577a27a056016805572872e7e891d770413409f229c12990c017c84
00000001e7a4f93a0e9c09883e248e014670d9ac08cf89c156ef660e0000003a000000003a59e3c85f2dccb43cfd6212a311fcca52650f976b46e78624fbffb85e76b10c508fab901a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
GOLDEN 779c1a99
JSON
da529cea4c4f29779fd68d36105af2b756bbaeb855366e8e17376a0501114392
00000001e7a4f93a0e9c09883e248e014670d9ac08cf89c156ef660e0000003a000000004c7a7004eada6c415ecee271698e6ec520b6a55a035ca5134b2380eb4eba4b1c508fab961a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000


JSON
eb4fe5578d07258f6c20042aa6570fb5dc6f713270a24478a68b39ed70a9be47
0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f000000000a6b650ec16629c6b7dffc0f44ae2a2b262dc03e2c746aa5aeb83a6f679bd20ab508fbc2f1a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
JSON
4fd08a61166619a9b91a72138994801dcdc065eeccbc87be135d115c13546bcd
0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f0000000000440869cc57b190330803eca919aef91ec96ca3e7b744422c133118d21f0e7e8508fbc431a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000
GOLDEN 75967de3
JSON
ecb213bb5e1313339e5cd2e65932e3abadf13b2ac8937321604a40d2c3fee107
0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f000000000b89eeb3693148086b1a79a32e88341073786397255b6b524219c910006dfd4f4508fbc571a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000
00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000
ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000


*/

#if 0
	char midstate_str[] = "";
	char data_str[] = "";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 0
	char midstate_str[] = "ecb213bb5e1313339e5cd2e65932e3abadf13b2ac8937321604a40d2c3fee107";
	char data_str[] = "0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f000000000b89eeb3693148086b1a79a32e88341073786397255b6b524219c910006dfd4f4508fbc571a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif


// data "0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f000000000b89eeb3693148086b1a79a32e88341073786397255b6b524219c910006dfd4f4508fbc571a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
#if 0
	char midstate_str[] = "eb4fe5578d07258f6c20042aa6570fb5dc6f713270a24478a68b39ed70a9be47";
	char data_str[] = "0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f000000000a6b650ec16629c6b7dffc0f44ae2a2b262dc03e2c746aa5aeb83a6f679bd20ab508fbc2f1a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 0	// THIS ONE IS VALID with nonce 75967de3 (checked via checkhash.py)
	char midstate_str[] = "4fd08a61166619a9b91a72138994801dcdc065eeccbc87be135d115c13546bcd";
	char data_str[] = "0000000181f96736f60a2bef6235ec7e1b2aa86ec8cef5369694596d000003f0000000000440869cc57b190330803eca919aef91ec96ca3e7b744422c133118d21f0e7e8508fbc431a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	// byte index      00                              16                              32                              48                              64                      76      80                              96                              112                             128
	// NB BIG ENDIAN   << ---------------------------------------------------- IGNORE FIRST 64 ------------------------------------------------------- >><< -------------------<NONCE >< one  >------------------------------------------------------------------------< length 64bit  >>
	// The first 64 bytes are already hashed as midstate, so we only use the second 64 bytes, into which we insert the nonce at index 76, it is followed by '1' (big endian so shows as 00000080), pad with zeroes then finish with 64 bit length (again big endian)
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 0
	char midstate_str[] = "a05f72040d21ae874e7abb671a16c520f65b27c0fe8fff32bfdc0ccf0119886f";
	char data_str[] = "00000001e7a4f93a0e9c09883e248e014670d9ac08cf89c156ef660e0000003a000000007aef3c141a26ecf22af62d6779290ea3fffaf9c19fb7daf652fee184d30d3131508fab7c1a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 0
	char midstate_str[] = "96a1e5cb2577a27a056016805572872e7e891d770413409f229c12990c017c84";
	char data_str[] = "00000001e7a4f93a0e9c09883e248e014670d9ac08cf89c156ef660e0000003a000000003a59e3c85f2dccb43cfd6212a311fcca52650f976b46e78624fbffb85e76b10c508fab901a0513c500000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000";
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";
#endif

#if 1
	// midstate_str and data_str are supplied as parameters

	// These are not used, but required to be defined ...
	char hash_str[] = "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000";
	char target_str[] = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000";

	uint32_t golden_nonce = 0;
	if (sscanf(golden_nonce_str, "%x", &golden_nonce) != 1)
	{
		fprintf(stderr,"ERROR invalid hex value for golden_nonce\n");
		return 1;
	}
#endif
	struct work work;

	// Try swapping the endinan'ness (NB only works for multiples of 4 bytes)
	// BUT note the comment up above at ... static inline void LOAD_OP(int I, u32 *W, const u8 *input)
											/* byteswap is commented out, because bitcoin input
											* is already big-endian */
	// So these should ARE NOT needed then ...
	// reversehex(midstate_str);
	// reversehex(data_str);
	// reversehex(hash_str);		// These are ignored anyway
	// reversehex(target_str);		// ditto

	int len = strlen(midstate_str) + strlen(data_str) + strlen(hash_str) + strlen(target_str) + 4;	// Allow for four terminators
	json_t *json_data = (json_t *)malloc(len);	// Now free'd on return
	if (!json_data)
		return 1;		// Malloc ERROR
	
	// Concatenate strings, but preserve NULL separators
	char *p = (char*)json_data;
	strcpy(p, midstate_str); p += (strlen(p) + 1 );
	strcpy(p, data_str); p += (strlen(p) + 1 );
	strcpy(p, hash_str); p += (strlen(p) + 1 );
	strcpy(p, target_str);

#if 0 // DEBUG
	printf("json_data=<");
	for (int i=0; i<len; i++)
		printf("%c",json_data[i]);
	printf(">\n");
#endif

	bool res = work_decode(json_data, &work);

	// Look at work.data, specifically to see how its been packed, since the first 64 bytes are ignored
#if 0 // DEBUG
	printf("work_data=<");
	for (int i=0; i<128; i++)
		printf("%02x",work.data[i]);
	printf(">\n");
#endif

	if (!res)
	{
		printf("ERROR: work_decode res = %d\n", res);
		return 1;	// ABORT
	}

	uint32_t max_nonce = golden_nonce;

	unsigned long hashes_done = 0;
	int thr_id = 0;
	
	// cpu-miner.c calls thusly...
	// MJ I have modified scanhash_c() to scan max_nonce only
	
	// STRANGE, work_decode sets hash1 but we IGNORE it and pass hash, which is UNINITIALIZED.
	// The other algorithms DO use hash1 and hash though
	// AHA scanhash_c IGNORES the hash parameter entirely (its actually the sha256 output), and as currently coded
	// it ignores target too ... it just checks for ((DWORD)hash)[7]==0, which is currently the same thing

	// printf("gn = %x\n", golden_nonce);

	bool rc = scanhash_c(thr_id, work.midstate, work.data + 64,		// NB First 64 bytes of data are ignored
			        work.hash, work.target,
					max_nonce, &hashes_done);

	// printf("scanhash_c rc = %d %s\n", rc, rc ? "MATCH" : "");

	// Try it reversed ... no need, the first one gives correct hash1
#if 0
	golden_nonce = ntohl(golden_nonce);

	printf("gn = %x\n", golden_nonce);

	max_nonce = golden_nonce + 5;	// MJ We scan from golden_nonce -5 to +5

	rc = scanhash_c(thr_id, work.midstate, work.data + 64,
			        work.hash, work.target,
					max_nonce, &hashes_done);

	printf("scanhash_c rc = %d %s\n", rc, rc ? "MATCH" : "BAD");
#endif

	// Need to free memory when used in mine.c
	if (work_restart)
	{
		free(work_restart);
		work_restart = NULL;
	}

	if (json_data)
	{
		free(json_data);
		json_data = NULL;
	}

	return !rc;	// NB Invert rc since want to return 0 for success (fixed v06)
}

#if 0	// Remove main() when used in mine.c
int main(int argc, char *argv[])
{
	// MJ Allocate some memory for work_restart (we don't bother freeing it)
	work_restart = (struct work_restart*) malloc (sizeof(struct work_restart));
	if (!work_restart)
		return 1;

	// Now requires command line parameters: golden_nonce data
	// Do not quote the hex strings. I hope they fit!!

	if (argc != 4)
	{
		fprintf(stderr, "usage: sha256_generic golden_nonce midstate data\n");
		fprintf(stderr, "NB prefix golden_nonce with 0x but not midstate or data\n");
		return 1;
	}

	if ((strlen(argv[1]) < 3) || (strncmp(argv[1],"0x",2) && strncmp(argv[1],"0X",2)))
	{
		fprintf(stderr, "usage: sha256_generic golden_nonce midstate data\n");
		fprintf(stderr, "NB prefix golden_nonce with 0x but not midstate or data\n");
		return 1;
	}

	// scan(0x75967de3);	// TEST nonce (VALID) - old version with int

	// OOPS, got these backwards, fixed in v05
	// OOPS AGAIN, switch it back, and change scan to return 0 for success (else syntax errors are
	// treated as success, fixed in v06
	if (!scan(argv[1], argv[2], argv[3]))
		return 0;	// MATCH

	return 9;		// NO MATCH
}
#endif
